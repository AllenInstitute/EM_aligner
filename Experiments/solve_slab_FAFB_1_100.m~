% Example script to solve a FAFBv12 slab for an existing set of point matches
%
% Assumes that all the work for generating point-matches has been done
% at the tile level
%
% Author: Khaled Khairy
%%%%%%%%%%%%%%%%%%%%%%%%% [0] configure collections and prepare quantities
clc;kk_clock;

nfirst = 1;
nlast  = 25;

% configure source collection
rcsource.stack          = 'v12_acquire_merged';
rcsource.owner          ='flyTEM';
rcsource.project        = 'FAFB00';
rcsource.service_host   = '10.37.5.60:8080';
rcsource.baseURL        = ['http://' rcsource.service_host '/render-ws/v1'];
rcsource.verbose        = 1;


% configure align collection
rctarget_align.stack          = ['EXP_dmesh_P1_' num2str(nfirst) '_' num2str(nlast)];
rctarget_align.owner          = 'flyTEM';
rctarget_align.project        = 'test';
rctarget_align.service_host   = '10.37.5.60:8080';
rctarget_align.baseURL        = ['http://' rcsource.service_host '/render-ws/v1'];
rctarget_align.verbose        = 1;

% configure point-match collection
pm.server           = 'http://10.40.3.162:8080/render-ws/v1';
pm.owner            = 'flyTEM';
pm.match_collection = 'v12_dmesh';

% configure solver
opts.min_tiles = 2; % minimum number of tiles that constitute a cluster to be solved. Below this, no modification happens
opts.degree = 1;    % 1 = affine, 2 = second order polynomial, maximum is 3
opts.outlier_lambda = 1e3;  % large numbers result in fewer tiles excluded
opts.solver = 'backslash';
opts.min_points = 5;
opts.nbrs = 3;
opts.xs_weight = 1/10;
opts.stvec_flag = 0;   % i.e. do not assume rcsource providing the starting values.

% % test for best regularization parameter
% % This is the smallest that does not cause downscaling of tiles
% prepare
[L, ~, ~, pm_mx] = load_point_matches(nfirst, nlast, rcsource, pm, opts.nbrs, opts.min_points, opts.xs_weight); % disp(pm_mx{ix});
[L_vec, ntiles] = reduce_to_connected_components(L);
L_vec(ntiles<10) = [];

solve_time = [];
err = [];
scl = [];
count = 1;
for explambda = [-2:0.5: 6]
    disp(explambda);
    kkt = tic;
    opts.lambda = 10^explambda;
    opts.edge_lambda = 10^(explambda);
    %[mL2, A, err_res, R]= solve_slab(rcsource, pm, nfirst, nlast, [], opts);
    [mL2, err_res, R] = solve_clusters(L_vec, opts, opts.stvec_flag);   % solves individual clusters and reassembles them into one
    err(count) = max(err_res);
    
    % measure deformation
    parfor ix = 1:numel(mL2.tiles)
        t = mL2.tiles(ix);
        [U S V] = svd(t.tform.T(1:2, 1:2));
        detS(ix) = det(S);
    end
%     states = [mL2.tiles(:).state]==1;
%     detS = detS(states); % remove entries for discarded tiles
    scl(count) = sum((detS-1).^2);  % for affine
    
    %scl(count) = sum(([mL2.tiles(20).tform.A(2) mL2.tiles(20).tform.A(2)]-1).^2)/2;  % for higher order
    %polynomials
    solve_time(count) = toc(kkt);
    disp(['time: ' num2str(solve_time(count))]);
    count = count + 1;
end
explambda = [-2:0.5: 6];
lambda = 10.^(explambda);
figure;plot(explambda, mat2gray(err), 'LineWidth', 1.0, 'Color', [1 0 0]);
hold on;plot(explambda, mat2gray(scl), 'LineWidth', 1.0,'Color', [0 0 1]);

%% solve

opts.lambda = 1e2;
opts.edge_lambda = 1e2;
%[mL, A]= solve_slab(rcsource, pm, nfirst, nlast, rctarget_align, opts);
[mL2, err_res, R] = solve_clusters(L_vec, opts, opts.stvec_flag);   % solves individual clusters and reassembles them into one
ingest_section_into_LOADING_collection(mL2, rctarget_align, rcsource, pwd, 1);
resp = set_renderer_stack_state_complete(rctarget_align);

% render

















